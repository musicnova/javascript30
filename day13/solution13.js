/**
 * @param {number} millis
 * @return {Promise}
 */
async function sleep(millis) {
/**
 * РЕШЕНИЕ ЗАДАЧИ LEETCODE 2621 - SLEEP
 * ====================================
 * 
 * ПОДРОБНОЕ ОПИСАНИЕ АЛГОРИТМА:
 * ============================
 * 
 * 1. СУТЬ ЗАДАЧИ:
 *    Необходимо создать асинхронную функцию sleep, которая имитирует задержку
 *    на заданное количество миллисекунд и возвращает Promise.
 * 
 * 2. КЛЮЧЕВЫЕ КОНЦЕПЦИИ:
 *    - Promise (промисы) - объекты для работы с асинхронными операциями
 *    - setTimeout - функция для создания задержки выполнения кода
 *    - async/await - синтаксический сахар для работы с промисами
 *    - Event Loop - механизм JavaScript для обработки асинхронных операций
 * 
 * 3. АЛГОРИТМ РЕШЕНИЯ:
 *    a) Функция принимает параметр millis (количество миллисекунд задержки)
 *    b) Создаем новый Promise с помощью конструктора Promise
 *    c) В executor функции промиса используем setTimeout
 *    d) setTimeout вызывает resolve через millis миллисекунд
 *    e) Возвращаем созданный промис
 * 
 * 4. ПРИНЦИП РАБОТЫ setTimeout:
 *    - setTimeout не блокирует выполнение других операций
 *    - Функция помещается в очередь задач (task queue) после истечения времени
 *    - Event Loop перемещает задачу из очереди в call stack когда он свободен
 *    - Это обеспечивает неблокирующую природу JavaScript
 * 
 * 5. МЕХАНИЗМ PROMISE:
 *    - Promise имеет три состояния: pending, fulfilled, rejected
 *    - resolve() переводит промис в состояние fulfilled
 *    - После вызова resolve промис считается завершенным успешно
 *    - .then() и await могут ожидать завершения промиса
 * 
 * 6. АСИНХРОННОСТЬ:
 *    - async функция автоматически возвращает Promise
 *    - await приостанавливает выполнение до разрешения промиса
 *    - Во время ожидания JavaScript может выполнять другие задачи
 * 
 * @param {number} millis - количество миллисекунд для задержки
 * @return {Promise} промис, который разрешается через millis миллисекунд
 */

    return new Promise(resolve => {
        setTimeout(resolve, millis);
    });

/**
 * ДОПОЛНИТЕЛЬНЫЕ КОММЕНТАРИИ И ОТВЕТЫ НА ВОЗМОЖНЫЕ ВОПРОСЫ:
 * ========================================================
 * 
 * Q1: Почему мы используем Promise вместо просто setTimeout?
 * A1: setTimeout сам по себе не возвращает Promise. Чтобы функция sleep
 *     могла использоваться с async/await или .then(), нам нужно обернуть
 *     setTimeout в Promise. Это позволяет интегрировать задержку в
 *     асинхронную цепочку выполнения.
 * 
 * Q2: Можно ли написать это решение по-другому?
 * A2: Да, есть несколько вариантов:
 *     
 *     Вариант 1 (без return):
 *     async function sleep(millis) {
 *         await new Promise(resolve => setTimeout(resolve, millis));
 *     }
 *     
 *     Вариант 2 (без async):
 *     function sleep(millis) {
 *         return new Promise(resolve => setTimeout(resolve, millis));
 *     }
 *     
 *     Все варианты функционально эквивалентны.
 * 
 * Q3: Почему setTimeout принимает resolve без скобок?
 * A3: resolve - это функция, и мы передаем ссылку на нее в setTimeout.
 *     setTimeout вызовет эту функцию через millis миллисекунд.
 *     Это равносильно setTimeout(() => resolve(), millis).
 * 
 * Q4: Что происходит, если millis равно 0?
 * A4: Даже при millis = 0, функция остается асинхронной. setTimeout(resolve, 0)
 *     добавляет resolve в очередь задач, что означает выполнение в следующем
 *     тике event loop'а, а не немедленно.
 * 
 * Q5: Насколько точна задержка?
 * A5: setTimeout не гарантирует точное время выполнения. Фактическая задержка
 *     может быть больше указанной из-за:
 *     - Загруженности основного потока
 *     - Других задач в очереди
 *     - Минимального разрешения таймера браузера (обычно 4мс)
 * 
 * Q6: Можно ли отменить выполнение sleep?
 * A6: Стандартная реализация не поддерживает отмену. Для этого нужно
 *     сохранить ID таймера и использовать clearTimeout:
 *     
 *     function cancellableSleep(millis) {
 *         let timeoutId;
 *         const promise = new Promise((resolve, reject) => {
 *             timeoutId = setTimeout(resolve, millis);
 *         });
 *         promise.cancel = () => clearTimeout(timeoutId);
 *         return promise;
 *     }
 * 
 * Q7: Какая сложность по времени и памяти?
 * A7: Временная сложность: O(1) - константное время для создания промиса
 *     Пространственная сложность: O(1) - константная память
 *     Примечание: фактическое время выполнения зависит от millis
 * 
 * Q8: Как эта функция используется в реальных приложениях?
 * A8: Практические применения:
 *     - Throttling/debouncing запросов к API
 *     - Имитация сетевых задержек в тестах
 *     - Создание анимационных эффектов с задержками
 *     - Ограничение частоты выполнения операций
 *     - Retry логика с экспоненциальной задержкой
 * 
 * Q9: Есть ли альтернативы setTimeout для более точного времени?
 * A9: Для более точного времени можно использовать:
 *     - performance.now() для измерения времени
 *     - requestAnimationFrame для анимаций
 *     - Web Workers для тяжелых вычислений
 *     Но для простых задержек setTimeout остается стандартным решением.
 * 
 * Q10: Почему функция помечена как async?
 * A10: Пометка async является опциональной в данном случае, так как мы
 *      явно возвращаем Promise. Однако это делает код более читаемым и
 *      указывает на асинхронную природу функции. async автоматически
 *      оборачивает возвращаемое значение в Promise.
 * 
 * ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ:
 * =====================
 * 
 * // Пример 1: Использование с async/await
 * async function example1() {
 *     console.log('Начало');
 *     await sleep(1000);
 *     console.log('Прошла секунда');
 * }
 * 
 * // Пример 2: Использование с .then()
 * sleep(500).then(() => {
 *     console.log('Прошло полсекунды');
 * });
 * 
 * // Пример 3: Цепочка задержек
 * async function sequence() {
 *     await sleep(100);
 *     console.log('Шаг 1');
 *     await sleep(200);
 *     console.log('Шаг 2');
 *     await sleep(300);
 *     console.log('Завершено');
 * }
 * 
 * // Пример 4: Retry с задержкой
 * async function retryWithDelay(fn, retries = 3, delay = 1000) {
 *     for (let i = 0; i < retries; i++) {
 *         try {
 *             return await fn();
 *         } catch (error) {
 *             if (i === retries - 1) throw error;
 *             await sleep(delay);
 *         }
 *     }
 * }
 */
}

/** 
 * let t = Date.now()
 * sleep(100).then(() => console.log(Date.now() - t)) // 100
 */
