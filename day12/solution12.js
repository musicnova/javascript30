/**
 * @param {Promise} promise1
 * @param {Promise} promise2
 * @return {Promise}
 */
var addTwoPromises = async function(promise1, promise2) {
/**
 * LeetCode 2723. Add Two Promises
 * 
 * ДЕТАЛЬНОЕ ОПИСАНИЕ АЛГОРИТМА РЕШЕНИЯ:
 * 
 * Задача требует создать функцию, которая принимает два промиса, каждый из которых
 * разрешается с числовым значением, и возвращает новый промис, который разрешается
 * с суммой этих двух чисел.
 * 
 * АЛГОРИТМ:
 * 1. Поскольку функция уже объявлена как async, мы можем использовать await
 * 2. Есть два основных подхода:
 *    а) Последовательное ожидание: await promise1, затем await promise2
 *    б) Параллельное ожидание: Promise.all([promise1, promise2])
 * 
 * 3. Выбираем параллельный подход, так как он более эффективен:
 *    - Оба промиса начинают выполняться одновременно
 *    - Общее время выполнения = max(время promise1, время promise2)
 *    - При последовательном подходе время = время promise1 + время promise2
 * 
 * 4. Используем деструктуризацию для получения значений из результата Promise.all
 * 5. Возвращаем сумму полученных значений
 * 
 * ВРЕМЕННАЯ СЛОЖНОСТЬ: O(1) - операция сложения
 * ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ: O(1) - только переменные для хранения результатов
 * 
 * @param {Promise} promise1 - Промис, который разрешается с числом
 * @param {Promise} promise2 - Промис, который разрешается с числом  
 * @return {Promise} - Промис, который разрешается с суммой двух чисел
 */

    // Используем Promise.all для параллельного ожидания обоих промисов
    // Это эффективнее, чем последовательное ожидание с await
    const [value1, value2] = await Promise.all([promise1, promise2]);
    
    // Возвращаем сумму полученных значений
    return value1 + value2;


/**
 * ОТВЕТЫ НА ВОЗМОЖНЫЕ ВОПРОСЫ:
 * 
 * В: Почему используется Promise.all вместо последовательных await?
 * О: Promise.all выполняет промисы параллельно, что быстрее. Если promise1 
 *    выполняется 50мс, а promise2 - 30мс, то Promise.all завершится за 50мс,
 *    а последовательные await - за 80мс.
 * 
 * В: Что произойдет, если один из промисов отклонится (reject)?
 * О: Promise.all немедленно отклонится с ошибкой первого отклоненного промиса.
 *    Это желательное поведение для данной задачи, так как мы не можем сложить
 *    числа, если одно из них недоступно.
 * 
 * В: Можно ли решить без Promise.all?
 * О: Да, можно использовать последовательные await:
 *    const value1 = await promise1;
 *    const value2 = await promise2;
 *    return value1 + value2;
 *    Но это менее эффективно.
 * 
 * В: Почему функция объявлена как async?
 * О: async функции автоматически возвращают Promise, даже если мы возвращаем
 *    обычное значение. Это соответствует требованию задачи вернуть Promise.
 * 
 * В: Что если промисы разрешаются не с числами?
 * О: По условию задачи гарантируется, что промисы разрешаются с числами.
 *    Если бы это было не так, JavaScript попытался бы привести значения к числам.
 * 
 * В: Влияет ли порядок промисов в Promise.all на результат?
 * О: Нет, так как сложение коммутативно (a + b = b + a). Порядок в массиве
 *    Promise.all сохраняется в результате, но для сложения это не важно.
 * 
 * В: Можно ли использовать Promise.allSettled?
 * О: Технически да, но не рекомендуется для данной задачи. Promise.allSettled
 *    ждет завершения всех промисов даже при ошибках, что излишне для простого
 *    сложения двух чисел.
 * 
 * В: Как тестировать это решение?
 * О: Пример:
 *    const p1 = new Promise(resolve => setTimeout(() => resolve(2), 20));
 *    const p2 = new Promise(resolve => setTimeout(() => resolve(5), 60));
 *    addTwoPromises(p1, p2).then(result => console.log(result)); // 7
 * 
 * В: Есть ли альтернативные способы записи деструктуризации?
 * О: Да, можно без деструктуризации:
 *    const results = await Promise.all([promise1, promise2]);
 *    return results[0] + results[1];
 *    Но деструктуризация более читаема.
 */
};

/**
 * addTwoPromises(Promise.resolve(2), Promise.resolve(2))
 *   .then(console.log); // 4
 */
