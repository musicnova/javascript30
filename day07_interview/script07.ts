/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */


function addTwoNumbers(l1: ListNode | null, l2: ListNode | null): ListNode | null {
/**
 * ДЕТАЛЬНОЕ ОПИСАНИЕ АЛГОРИТМА РЕШЕНИЯ ЗАДАЧИ "ADD TWO NUMBERS"
 * 
 * Задача: Сложить два числа, представленных в виде связанных списков, где цифры хранятся в обратном порядке.
 * 
 * ПОНИМАНИЕ ПРОБЛЕМЫ:
 * - У нас есть два связанных списка: l1 и l2
 * - Каждый узел содержит одну цифру от 0 до 9
 * - Цифры хранятся в ОБРАТНОМ порядке (младшие разряды идут первыми)
 * - Например: [2,4,3] представляет число 342, [5,6,4] представляет число 465
 * - Результат: 342 + 465 = 807, что представляется как [7,0,8]
 * 
 * ОСНОВНАЯ ИДЕЯ АЛГОРИТМА:
 * 1. Поскольку цифры уже в обратном порядке, мы можем складывать их напрямую, начиная с головы списков
 * 2. Имитируем процесс сложения "в столбик", как мы делаем на бумаге
 * 3. Обрабатываем перенос (carry) когда сумма цифр > 9
 * 4. Создаем новый связанный список для результата
 * 
 * ПОШАГОВЫЙ АЛГОРИТМ:
 * 1. Инициализируем фиктивный узел (dummy node) для результата
 * 2. Инициализируем указатель current для построения результирующего списка
 * 3. Инициализируем переменную carry = 0 для обработки переноса
 * 4. Проходим по обоим спискам одновременно в цикле while:
 *    - Берем значения текущих узлов (или 0, если узел отсутствует)
 *    - Вычисляем сумму: val1 + val2 + carry
 *    - Создаем новый узел со значением (sum % 10)
 *    - Обновляем carry = sum / 10
 *    - Перемещаем указатели к следующим узлам
 * 5. После завершения цикла, если остался carry > 0, создаем дополнительный узел
 * 6. Возвращаем результат, пропуская фиктивный узел
 * 
 * ВРЕМЕННАЯ СЛОЖНОСТЬ: O(max(m, n)), где m и n - длины входных списков
 * ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ: O(max(m, n)) для результирующего списка
 */

    // Создаем фиктивный узел для упрощения построения результирующего списка
    // Это позволяет нам избежать специальной обработки первого узла
    const dummyHead: ListNode = new ListNode(0);
    
    // Указатель для построения результирующего списка
    // Начинаем с фиктивного узла
    let current: ListNode = dummyHead;
    
    // Переменная для хранения переноса (carry) из предыдущей позиции
    // Когда сумма двух цифр >= 10, мы переносим 1 в следующий разряд
    let carry: number = 0;
    
    // Продолжаем цикл пока есть узлы в любом из списков или есть перенос
    // Это важно: даже если оба списка закончились, может остаться перенос
    while (l1 !== null || l2 !== null || carry !== 0) {
        // Получаем значение из первого списка или 0, если список закончился
        const val1: number = l1 ? l1.val : 0;
        
        // Получаем значение из второго списка или 0, если список закончился
        const val2: number = l2 ? l2.val : 0;
        
        // Вычисляем общую сумму: значения из обоих узлов + перенос
        const totalSum: number = val1 + val2 + carry;
        
        // Вычисляем перенос для следующей итерации
        // Если сумма >= 10, то carry = 1, иначе carry = 0
        carry = Math.floor(totalSum / 10);
        
        // Создаем новый узел с цифрой результата (последняя цифра суммы)
        const digit: number = totalSum % 10;
        current.next = new ListNode(digit);
        
        // Перемещаем указатель к только что созданному узлу
        current = current.next;
        
        // Переходим к следующим узлам в обоих списках, если они существуют
        if (l1) {
            l1 = l1.next;
        }
        if (l2) {
            l2 = l2.next;
        }
    }
    
    // Возвращаем результат, пропуская фиктивный узел
    // dummyHead.next указывает на первый реальный узел результата
    return dummyHead.next;

/**
 * ОТВЕТЫ НА ВОЗМОЖНЫЕ ВОПРОСЫ:
 * 
 * 1. Q: Почему мы используем фиктивный узел (dummy node)?
 *    A: Фиктивный узел упрощает код и избавляет от необходимости специальной
 *       обработки первого узла результата. Без него нам пришлось бы отдельно
 *       обрабатывать создание головы списка.
 * 
 * 2. Q: Что произойдет, если один список длиннее другого?
 *    A: Алгоритм корректно обработает эту ситуацию. Когда один список заканчивается,
 *       мы используем 0 как значение для отсутствующих узлов и продолжаем обработку
 *       оставшихся узлов другого списка.
 * 
 * 3. Q: Как обрабатывается последний перенос?
 *    A: После завершения обоих списков, условие цикла (carry !== 0) гарантирует,
 *       что если остался перенос, будет создан дополнительный узел. Например,
 *       99 + 1 = 100, что даст [0, 0, 1] в результирующем списке.
 * 
 * 4. Q: Можно ли изменить входные списки вместо создания нового?
 *    A: Технически да, но это плохая практика, так как нарушает принцип неизменности
 *       входных данных. Создание нового списка - более безопасный подход.
 * 
 * 5. Q: Почему мы используем Math.floor для вычисления carry?
 *    A: В TypeScript/JavaScript деление может дать дробное число. Math.floor
 *       гарантирует получение целого числа. Для данной задачи можно также
 *       использовать Math.trunc или операцию ~~(totalSum / 10).
 * 
 * 6. Q: Что произойдет с пустыми списками?
 *    A: По условию задачи списки не могут быть пустыми, но если бы они были,
 *       алгоритм вернул бы null (так как dummyHead.next был бы null).
 * 
 * 7. Q: Как работает пример [9,9,9,9,9,9,9] + [9,9,9,9]?
 *    A: Пошагово:
 *       - 9+9=18 → digit=8, carry=1
 *       - 9+9+1=19 → digit=9, carry=1  
 *       - 9+9+1=19 → digit=9, carry=1
 *       - 9+9+1=19 → digit=9, carry=1
 *       - 9+0+1=10 → digit=0, carry=1
 *       - 9+0+1=10 → digit=0, carry=1
 *       - 9+0+1=10 → digit=0, carry=1
 *       - 0+0+1=1 → digit=1, carry=0
 *       Результат: [8,9,9,9,0,0,0,1]
 * 
 * 8. Q: Можно ли решить задачу рекурсивно?
 *    A: Да, можно написать рекурсивное решение, передавая carry как параметр.
 *       Но итеративное решение более эффективно по памяти (не использует стек вызовов).
 * 
 * 9. Q: Оптимально ли данное решение?
 *    A: Да, это оптимальное решение с временной сложностью O(max(m,n)) и
 *       пространственной сложностью O(max(m,n)), где m и n - длины входных списков.
 *       Мы должны посетить каждый узел хотя бы один раз, поэтому лучше быть не может.
 * 
 * 10. Q: Как протестировать это решение?
 *     A: Можно создать тестовые случаи:
 *        - Обычное сложение: [2,4,3] + [5,6,4] = [7,0,8]
 *        - С переносом в конце: [5] + [5] = [0,1]
 *        - Разная длина: [9,9] + [1] = [0,0,1]
 *        - Одинаковые цифры: [0] + [0] = [0]
 */
}
