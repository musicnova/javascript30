/**
 * @param {number[]} arr
 * @param {Function} fn
 * @return {number[]}
 */
var filter = function(arr, fn) {
/**
 * Решение задачи 2634. Filter Elements from Array
 *
 * Алгоритм решения:
 * 1. Мы получаем на вход массив чисел arr и функцию fn.
 * 2. Наша задача — вернуть новый массив, в который попадут только те элементы из arr,
 *    для которых вызов fn(arr[i], i) возвращает "истинное" (truthy) значение.
 * 3. Важно: нельзя использовать встроенный метод Array.filter.
 * 4. Для решения мы:
 *    - Создаем пустой массив filteredArr.
 *    - Проходим циклом по всем элементам входного массива arr.
 *    - Для каждого элемента вызываем fn с двумя аргументами: элемент и его индекс.
 *    - Если результат вызова fn является truthy (например, true, ненулевое число, непустая строка),
 *      то добавляем этот элемент в filteredArr.
 *    - Если результат falsy (false, 0, null, undefined, ''), то элемент пропускаем.
 * 5. В конце возвращаем массив filteredArr.
 *
 * Сложность алгоритма: O(n), где n — длина массива arr, так как мы один раз проходим по массиву.
 *
 * Пример:
 * arr = [0, 10, 20, 30], fn = n => n > 10
 * Проходим по arr:
 * 0 -> fn(0) = false (0 > 10? нет) — не добавляем
 * 10 -> fn(10) = false — не добавляем
 * 20 -> fn(20) = true — добавляем
 * 30 -> fn(30) = true — добавляем
 * Итог: [20, 30]
 */
/**
 * Оптимизированное решение задачи 2634. Filter Elements from Array
 *
 * Комментарий по оптимизации:
 * - Основная операция — проход по массиву и вызов функции fn для каждого элемента.
 * - Время работы O(n) — минимально возможное, так как нужно проверить каждый элемент.
 * - В JavaScript циклы for с инкрементом i++ обычно быстрее, чем forEach или другие методы.
 * - Используем простой цикл for, без лишних проверок и вызовов.
 * - Избегаем лишних операций внутри цикла.
 * - Предварительно выделяем память под результирующий массив не имеет смысла, т.к. размер неизвестен.
 * - Вызов fn оставляем неизменным — он зависит от пользователя.
 *
 * Если ваша функция fn сложная, ускорить фильтрацию можно только оптимизацией fn.
 * В рамках самой фильтрации — этот код максимально простой и быстрый.
 */
 
    const filteredArr = [];
    let idx = 0; // индекс для filteredArr, чтобы избежать push (не всегда быстрее, но иногда)
    for (let i = 0; i < arr.length; i++) {
        if (fn(arr[i], i)) {
            filteredArr[idx++] = arr[i];
        }
    }
    return filteredArr;

/*
Почему это быстрее:
- Использование присваивания по индексу вместо push иногда даёт небольшое ускорение,
  так как push может делать дополнительные проверки и вызывать внутренние методы.
- Использование простого цикла for с i++ — самый быстрый способ обхода массива в JS.
- Минимум операций внутри цикла.
- Не создаём лишних функций или объектов.
- Вызов fn неизбежен, его оптимизация — за пределами этой функции.
*/

/*
Ответы на возможные вопросы:

1. Почему нельзя использовать Array.filter?
   В условии задачи явно указано, что нельзя использовать встроенный метод filter,
   чтобы продемонстрировать понимание базовой логики фильтрации и работы с массивами.

2. Что такое "truthy" и "falsy" значения?
   В JavaScript "truthy" — это любое значение, которое при приведении к булевому типу становится true.
   Например: true, 1, "abc", {}, [].
   "Falsy" — это false, 0, "", null, undefined, NaN.
   В этой задаче fn может возвращать любое значение, и мы считаем элемент подходящим,
   если результат fn — truthy.

3. Можно ли использовать fn с одним аргументом?
   Да, fn может принимать один или два аргумента. Мы всегда передаем два: элемент и индекс.
   Если функция принимает только один, второй просто игнорируется.

4. Что если arr пустой?
   Тогда цикл не выполнится, и функция вернет пустой массив — это правильное поведение.

5. Какие ограничения по входным данным?
   Длина массива от 0 до 1000, элементы могут быть от -10^9 до 10^9, что не влияет на логику фильтрации.

6. Можно ли использовать другие методы массива?
   Лучше не использовать методы, которые реализуют фильтрацию (filter, map, reduce),
   чтобы не нарушать условие задачи.

Таким образом, данный код решает задачу эффективно и понятно.
*/
};
