function maxProfit(prices: number[]): number {
/**
 * ЗАДАЧА: 121. Best Time to Buy and Sell Stock
 * 
 * ОПИСАНИЕ АЛГОРИТМА:
 * ===================
 * 
 * Цель: Найти максимальную прибыль от покупки и продажи акции за один раз.
 * Ограничения: Можно купить акцию только один раз и продать только один раз, 
 * причем продажа должна происходить после покупки.
 * 
 * ПОДХОД К РЕШЕНИЮ:
 * 
 * 1. ОСНОВНАЯ ИДЕЯ:
 *    - Нам нужно найти день с минимальной ценой для покупки
 *    - И день с максимальной ценой для продажи ПОСЛЕ дня покупки
 *    - Разность между этими ценами и будет максимальной прибылью
 * 
 * 2. ОПТИМАЛЬНЫЙ АЛГОРИТМ (One Pass):
 *    - Проходим по массиву цен только один раз (слева направо)
 *    - Отслеживаем минимальную цену, встреченную до текущего дня
 *    - Для каждого дня вычисляем потенциальную прибыль: текущая_цена - минимальная_цена
 *    - Сохраняем максимальную прибыль из всех вычисленных
 * 
 * 3. ПОЧЕМУ ЭТОТ ПОДХОД РАБОТАЕТ:
 *    - Если мы покупаем по минимальной цене до текущего дня,
 *      то продажа в текущий день даст максимально возможную прибыль на этот момент
 *    - Проверяя каждый день, мы найдем глобальный максимум прибыли
 * 
 * 4. СЛОЖНОСТЬ:
 *    - Временная: O(n) - один проход по массиву
 *    - Пространственная: O(1) - используем только две переменные
 * 
 * 5. ПРИМЕР РАБОТЫ:
 *    prices = [7, 1, 5, 3, 6, 4]
 *    
 *    День 0: цена=7, минЦена=7, прибыль=0
 *    День 1: цена=1, минЦена=1, прибыль=0  
 *    День 2: цена=5, минЦена=1, прибыль=4 (5-1)
 *    День 3: цена=3, минЦена=1, прибыль=4 (max(4, 3-1))
 *    День 4: цена=6, минЦена=1, прибыль=5 (max(4, 6-1))
 *    День 5: цена=4, минЦена=1, прибыль=5 (max(5, 4-1))
 *    
 *    Результат: максимальная прибыль = 5
 */

    // Если массив пустой или содержит только один элемент, прибыль невозможна
    if (prices.length <= 1) {
        return 0;
    }
    
    // Инициализируем минимальную цену первым элементом
    let minPrice = prices[0];
    
    // Инициализируем максимальную прибыль нулем
    let maxProfitValue = 0;
    
    // Проходим по массиву, начиная со второго элемента
    for (let i = 1; i < prices.length; i++) {
        const currentPrice = prices[i];
        
        // Вычисляем прибыль, если продадим в текущий день
        const currentProfit = currentPrice - minPrice;
        
        // Обновляем максимальную прибыль, если текущая больше
        maxProfitValue = Math.max(maxProfitValue, currentProfit);
        
        // Обновляем минимальную цену, если текущая цена меньше
        minPrice = Math.min(minPrice, currentPrice);
    }
    
    return maxProfitValue;

/**
 * ОТВЕТЫ НА ВОЗМОЖНЫЕ ВОПРОСЫ:
 * =============================
 * 
 * В: Почему мы не можем просто найти минимум и максимум в массиве?
 * О: Потому что максимум должен идти ПОСЛЕ минимума по времени (индексу).
 *    Если минимум находится после максимума, такая транзакция невозможна.
 * 
 * В: Что если все цены убывают (как в примере [7,6,4,3,1])?
 * О: В этом случае невозможно получить прибыль, поэтому функция вернет 0.
 *    Алгоритм корректно обрабатывает этот случай.
 * 
 * В: Можно ли решить эту задачу рекурсивно?
 * О: Да, но это будет менее эффективно. Рекурсивное решение будет иметь
 *    сложность O(2^n) без мемоизации или O(n²) с мемоизацией.
 * 
 * В: Что если массив содержит отрицательные числа?
 * О: По условию задачи цены не могут быть отрицательными (0 <= prices[i] <= 10^4),
 *    но алгоритм работал бы и с отрицательными числами.
 * 
 * В: Как изменить алгоритм для множественных покупок/продаж?
 * О: Это уже другая задача (122. Best Time to Buy and Sell Stock II).
 *    Для множественных транзакций алгоритм был бы другим.
 * 
 * В: Можно ли использовать двойной цикл для решения?
 * О: Да, но это даст сложность O(n²). Для каждого дня покупки проверяем
 *    все дни продажи после него. Это менее эффективно, чем O(n) решение.
 * 
 * В: Что происходит с пустым массивом или массивом из одного элемента?
 * О: Функция возвращает 0, так как невозможно совершить транзакцию
 *    (нужно минимум 2 дня для покупки и продажи).
 * 
 * В: Как протестировать эту функцию?
 * О: Можно использовать примеры из условия задачи:
 *    - maxProfit([7,1,5,3,6,4]) должно вернуть 5
 *    - maxProfit([7,6,4,3,1]) должно вернуть 0
 *    - maxProfit([]) должно вернуть 0
 *    - maxProfit([5]) должно вернуть 0
 * 
 * В: Есть ли альтернативные подходы к решению?
 * О: Да, можно использовать:
 *    1. Динамическое программирование
 *    2. Подход "разделяй и властвуй"
 *    3. Kadane's algorithm (модификация)
 *    Но все они либо сложнее в реализации, либо менее эффективны.
 */
}
