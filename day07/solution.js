/**
 * @param {number[]} nums
 * @param {Function} fn
 * @param {number} init
 * @return {number}
 */
var reduce = function(nums, fn, init) {
    /**
 * ЗАДАЧА: 2626. Array Reduce Transformation
 * 
 * ДЕТАЛЬНЫЙ АЛГОРИТМ РЕШЕНИЯ:
 * 
 * Цель: Реализовать собственную версию метода Array.reduce() без использования встроенного метода.
 * 
 * Принцип работы reduce:
 * 1. Функция reduce принимает три параметра:
 *    - nums: массив чисел для обработки
 *    - fn: функция-редьюсер, которая принимает аккумулятор и текущий элемент
 *    - init: начальное значение аккумулятора
 * 
 * 2. Алгоритм пошагово:
 *    Шаг 1: Инициализируем переменную-аккумулятор значением init
 *    Шаг 2: Проходим по каждому элементу массива nums последовательно
 *    Шаг 3: Для каждого элемента вызываем функцию fn(аккумулятор, текущий_элемент)
 *    Шаг 4: Результат выполнения fn становится новым значением аккумулятора
 *    Шаг 5: Повторяем шаги 3-4 для всех элементов массива
 *    Шаг 6: Возвращаем финальное значение аккумулятора
 * 
 * 3. Особые случаи:
 *    - Если массив пустой (nums.length === 0), возвращаем init без изменений
 *    - Функция fn всегда получает ровно два аргумента: (accumulator, currentValue)
 * 
 * 4. Примеры работы:
 *    nums = [1,2,3,4], fn = (a,b) => a+b, init = 0
 *    Итерация 1: fn(0, 1) = 1
 *    Итерация 2: fn(1, 2) = 3  
 *    Итерация 3: fn(3, 3) = 6
 *    Итерация 4: fn(6, 4) = 10
 *    Результат: 10
 * 
 * 5. Временная сложность: O(n), где n - длина массива
 *    Пространственная сложность: O(1) - используем только одну переменную-аккумулятор
 */
    
    // Шаг 1: Инициализируем аккумулятор начальным значением
    let accumulator = init;
    
    // Шаг 2: Проходим по каждому элементу массива
    for (let i = 0; i < nums.length; i++) {
        // Шаг 3: Применяем функцию-редьюсер к аккумулятору и текущему элементу
        // Результат становится новым значением аккумулятора
        accumulator = fn(accumulator, nums[i]);
    }
    
    // Шаг 4: Возвращаем финальное значение аккумулятора
    return accumulator;

/**
 * ЧАСТО ЗАДАВАЕМЫЕ ВОПРОСЫ И ОТВЕТЫ:
 * 
 * Q1: Почему мы не можем использовать встроенный Array.reduce()?
 * A1: Задача специально требует реализовать собственную версию для понимания внутренней
 *     логики работы reduce. Это важно для изучения алгоритмов и функционального программирования.
 * 
 * Q2: Что происходит, если массив пустой?
 * A2: Если nums.length === 0, цикл for не выполнится ни разу, и функция вернет 
 *     изначальное значение init. Это корректное поведение согласно спецификации.
 * 
 * Q3: Может ли функция fn изменить исходный массив nums?
 * A3: Теоретически да, если fn каким-то образом получит доступ к nums, но по хорошей 
 *     практике функция-редьюсер должна быть чистой функцией без побочных эффектов.
 * 
 * Q4: Что если fn вернет не число?
 * A4: В JavaScript это допустимо. Аккумулятор может содержать любой тип данных.
 *     В данной задаче ожидается число, но реализация универсальна.
 * 
 * Q5: Почему используется цикл for, а не forEach или другие методы?
 * A5: Цикл for - самый базовый и производительный способ итерации. Использование
 *     других методов массива противоречило бы духу задачи "реализовать с нуля".
 * 
 * Q6: Как обрабатываются отрицательные числа или ноль?
 * A6: Никаких специальных обработок не требуется. Функция fn получает числа как есть,
 *     а логика их обработки зависит от конкретной реализации fn.
 * 
 * Q7: Можно ли оптимизировать эту реализацию?
 * A7: Текущая реализация уже оптимальна для общего случая. Возможные микрооптимизации:
 *     - Кеширование nums.length
 *     - Использование while вместо for
 *     Но они не дают существенного прироста производительности.
 * 
 * Q8: Чем эта реализация отличается от встроенного Array.reduce()?
 * A8: Основные отличия:
 *     - Встроенный reduce может не передавать начальное значение
 *     - Встроенный reduce передает дополнительные параметры (индекс, массив)
 *     - Встроенный reduce обрабатывает разреженные массивы
 *     - Встроенный reduce имеет больше проверок типов и безопасности
 * 
 * Q9: Какие практические применения у функции reduce?
 * A9: Reduce очень мощный инструмент:
 *     - Суммирование массивов: nums.reduce((a,b) => a+b, 0)
 *     - Поиск максимума: nums.reduce((a,b) => Math.max(a,b), -Infinity)
 *     - Группировка данных: превращение массива в объект
 *     - Композиция функций: создание цепочки преобразований
 *     - Подсчет элементов: создание словаря частотности
 * 
 * Q10: Что делать, если fn бросает исключение?
 * A10: В текущей реализации исключение прервет выполнение и всплывет наверх.
 *      В продакшн-коде стоило бы добавить обработку ошибок, но для учебной задачи
 *      это избыточно.
 * 
 * ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ:
 * 
 * // Пример 1: Суммирование
 * console.log(reduce([1,2,3,4], (a,b) => a+b, 0)); // 10
 * 
 * // Пример 2: Произведение
 * console.log(reduce([1,2,3,4], (a,b) => a*b, 1)); // 24
 * 
 * // Пример 3: Поиск максимума
 * console.log(reduce([1,5,3,9,2], (a,b) => Math.max(a,b), -Infinity)); // 9
 * 
 * // Пример 4: Подсчет символов (концептуально)
 * // reduce(['a','b','a'], (acc, char) => ({...acc, [char]: (acc[char]||0)+1}), {})
 * // Результат: {a: 2, b: 1}
 */ 
};
