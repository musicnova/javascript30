function twoSum(nums: number[], target: number): number[] {
    /*
    Алгоритм решения задачи Two Sum:
    1. Создаем пустую структуру данных Map для хранения чисел из массива и их индексов.
    2. Проходим по массиву nums по одному элементу за раз.
    3. Для каждого элемента вычисляем разницу diff = target - nums[i].
    4. Проверяем, содержится ли diff в Map:
       - Если содержится, значит мы нашли два числа, сумма которых равна target.
         Возвращаем массив с индексами этих двух чисел: [индекс diff, текущий индекс i].
       - Если не содержится, добавляем текущий элемент nums[i] и его индекс i в Map.
    5. Если пройдем весь массив и не найдем пару, возвращаем пустой массив (по условию задачи это не требуется, так как решение гарантировано).
    Этот подход позволяет найти пару за один проход по массиву, что даёт временную сложность O(n).
    */

    const map = new Map<number, number>(); // Хранит число -> индекс

    for (let i = 0; i < nums.length; i++) {
        const diff = target - nums[i];
        if (map.has(diff)) {
            return [map.get(diff)!, i];
        }
        map.set(nums[i], i);
    }

    return [];

/*
Ответы на вопросы:
- Функция принимает на вход массив чисел nums и целевое число target.
- Возвращает массив из двух индексов чисел, сумма которых равна target.
- Для поиска пары используется Map, которая хранит уже просмотренные числа и их индексы.
- При проходе по массиву для каждого числа вычисляется разница diff с target, и проверяется, есть ли diff в Map.
- Если есть, возвращаются индексы найденной пары.
- Сложность алгоритма: O(n), где n — длина массива nums, что эффективнее чем наивный O(n²).
- По условию задачи гарантируется, что решение существует и элементы не используются дважды.
*/

};
