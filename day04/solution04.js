/**
 * @param {integer} init
 * @return { increment: Function, decrement: Function, reset: Function }
 */
var createCounter = function(init) {    
/**
 * Алгоритм решения задачи "Counter II":
 * 
 * 1. Функция createCounter принимает начальное значение init.
 * 2. Внутри createCounter создается переменная current, которая хранит текущее значение счетчика.
 *    Изначально current равен init.
 * 3. Возвращается объект с тремя методами:
 *    - increment(): увеличивает current на 1, возвращает новое значение current.
 *    - decrement(): уменьшает current на 1, возвращает новое значение current.
 *    - reset(): сбрасывает current к начальному значению init, возвращает init.
 * 
 * Таким образом, объект-счетчик сохраняет состояние current между вызовами методов.
 * Это достигается замыканием — функции имеют доступ к переменной current, объявленной в createCounter.
 * 
 * В итоге мы получаем простой и эффективный способ управлять счетчиком с тремя операциями.
 */
    let current = init;

    return {
        increment: function() {
            current += 1;
            return current;
        },
        decrement: function() {
            current -= 1;
            return current;
        },
        reset: function() {
            current = init;
            return current;
        }
    };
/**
 * Ответы на возможные вопросы:
 * 
 * Q: Почему используем замыкание?
 * A: Замыкание позволяет сохранить состояние переменной current между вызовами методов объекта.
 *    Без замыкания current бы не сохранял значение и всегда сбрасывался.
 * 
 * Q: Можно ли изменить init после создания счетчика?
 * A: В данной реализации init фиксирован и не изменяется, так как это значение, с которым создается счетчик.
 *    Если нужно менять init, можно добавить дополнительный метод.
 * 
 * Q: Что будет, если init отрицательное?
 * A: Алгоритм корректно работает с любыми целыми числами в заданных ограничениях (-1000 <= init <= 1000).
 * 
 * Q: Какой тип возвращают методы?
 * A: Все методы возвращают число — текущее значение счетчика после операции.
 * 
 * Q: Можно ли использовать стрелочные функции?
 * A: Да, можно, но для наглядности и совместимости с разными версиями TS/JS здесь использованы обычные функции.
 * 
 * Q: Что если вызвать методы в произвольном порядке?
 * A: Счетчик корректно обновляет значение current в зависимости от вызванного метода, порядок не влияет на логику.
 */

};
