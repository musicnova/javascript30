/**
 * @param {Function} fn
 * @return {Function}
 */
var once = function(fn) {
/**
 * ЗАДАЧА 2666: Allow One Function Call
 * 
 * ОПИСАНИЕ АЛГОРИТМА РЕШЕНИЯ:
 * ============================
 * 
 * Цель: Создать функцию-обертку, которая позволяет вызвать переданную функцию только один раз.
 * 
 * Алгоритм работы:
 * 1. Используем замыкание (closure) для хранения состояния
 * 2. Создаем флаг `isCalled` для отслеживания того, была ли функция уже вызвана
 * 3. Создаем переменную `result` для хранения результата первого вызова
 * 4. Возвращаем новую функцию, которая:
 *    - При первом вызове: выполняет оригинальную функцию, сохраняет результат, устанавливает флаг
 *    - При последующих вызовах: просто возвращает undefined
 * 
 * Ключевые концепции:
 * - Замыкание (Closure): внутренняя функция имеет доступ к переменным внешней функции
 * - Состояние: флаг isCalled и переменная result сохраняются между вызовами
 * - Rest параметры (...args): позволяют передать любое количество аргументов
 * 
 * Временная сложность: O(1) для каждого вызова
 * Пространственная сложность: O(1) - только две переменные состояния
 */

    // Флаг для отслеживания того, была ли функция уже вызвана
    let isCalled = false;
    // Переменная для хранения результата первого вызова
    let result;
    
    // Возвращаем новую функцию с ограничением
    return function(...args) {
        // Если функция еще не была вызвана
        if (!isCalled) {
            // Устанавливаем флаг, что функция была вызвана
            isCalled = true;
            // Вызываем оригинальную функцию и сохраняем результат
            result = fn(...args);
            // Возвращаем результат первого вызова
            return result;
        }
        
        // Если функция уже была вызвана ранее, возвращаем undefined
        return undefined;
    };


/**
 * ОТВЕТЫ НА ВОЗМОЖНЫЕ ВОПРОСЫ:
 * ============================
 * 
 * В: Почему мы используем let вместо var для isCalled и result?
 * О: let обеспечивает блочную область видимости и предотвращает случайное 
 *    переопределение переменных. Это более безопасная практика в современном JavaScript.
 * 
 * В: Что такое замыкание и как оно работает здесь?
 * О: Замыкание - это способность внутренней функции получать доступ к переменным 
 *    внешней функции даже после того, как внешняя функция завершила выполнение.
 *    В нашем случае возвращаемая функция "запоминает" переменные isCalled и result.
 * 
 * В: Зачем нужны rest параметры (...args)?
 * О: Rest параметры позволяют принимать любое количество аргументов и передавать 
 *    их в оригинальную функцию. Это делает наше решение универсальным для любых функций.
 * 
 * В: Что произойдет, если оригинальная функция выбросит ошибку?
 * О: Ошибка будет выброшена при первом вызове, но флаг isCalled все равно станет true,
 *    поэтому последующие вызовы будут возвращать undefined.
 * 
 * В: Можно ли модифицировать это решение для сброса состояния?
 * О: Да, можно добавить метод reset(), но это выходит за рамки текущей задачи.
 *    Текущее требование - функция должна вызываться максимум один раз без возможности сброса.
 * 
 * В: Почему мы сохраняем result, а не вызываем функцию каждый раз?
 * О: По условию задачи, оригинальная функция должна быть вызвана только один раз.
 *    Сохранение результата позволяет избежать повторных вычислений и побочных эффектов.
 * 
 * В: Что если переданная функция возвращает undefined?
 * О: Это нормальная ситуация. Мы различаем "результат undefined от первого вызова" 
 *    и "undefined от последующих вызовов" по флагу isCalled.
 * 
 * В: Влияет ли контекст (this) на работу функции?
 * О: В текущей реализации контекст не сохраняется. Если нужно сохранить контекст,
 *    можно использовать fn.apply(this, args) вместо fn(...args).
 */ 
};

/**
 * let fn = (a,b,c) => (a + b + c)
 * let onceFn = once(fn)
 *
 * onceFn(1,2,3); // 6
 * onceFn(2,3,6); // returns undefined without calling fn
 */
