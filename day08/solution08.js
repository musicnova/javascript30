/**
 * @param {Function[]} functions
 * @return {Function}
 */
var compose = function(functions) {
/**
 * ЗАДАЧА: 2629. Function Composition
 * 
 * ДЕТАЛЬНОЕ ОПИСАНИЕ АЛГОРИТМА РЕШЕНИЯ:
 * =====================================
 * 
 * Композиция функций - это математическая операция, где результат одной функции
 * становится входным параметром для другой функции. В данной задаче нам нужно
 * создать функцию, которая принимает массив функций и возвращает новую функцию,
 * представляющую композицию всех функций из массива.
 * 
 * КЛЮЧЕВЫЕ МОМЕНТЫ:
 * 1. Композиция функций выполняется СПРАВА НАЛЕВО (от последней к первой)
 * 2. Если массив пустой, возвращаем функцию-идентичность f(x) = x
 * 3. Каждая функция принимает один параметр и возвращает один результат
 * 
 * ПРИМЕР РАБОТЫ:
 * Для functions = [f1, f2, f3] и входного значения x:
 * - Сначала применяем f3(x) = result1
 * - Затем применяем f2(result1) = result2  
 * - Наконец применяем f1(result2) = final_result
 * 
 * АЛГОРИТМ РЕШЕНИЯ:
 * 1. Проверяем, если массив функций пустой - возвращаем функцию-идентичность
 * 2. Используем методы массива для композиции:
 *    - reduceRight() для обхода массива справа налево
 *    - reduce() для обхода массива слева направо (но с обратной логикой)
 * 3. Применяем каждую функцию к результату предыдущей
 * 
 * ВРЕМЕННАЯ СЛОЖНОСТЬ: O(n), где n - количество функций в массиве
 * ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ: O(1)
 */

    // Если массив функций пустой, возвращаем функцию-идентичность
    if (functions.length === 0) {
        return function(x) {
            return x;
        };
    }
    
    // Возвращаем функцию, которая применяет композицию
    return function(x) {
        // Способ 1: Используем reduceRight для обхода справа налево
        return functions.reduceRight((accumulator, currentFunction) => {
            return currentFunction(accumulator);
        }, x);
        
        // Альтернативный способ 2: Используем reduce с обратной логикой
        // return functions.reduce((accumulator, currentFunction) => {
        //     return currentFunction(accumulator);
        // }, x);
        // Но в этом случае нужно обратить массив: functions.slice().reverse()
        
        // Альтернативный способ 3: Классический цикл
        // let result = x;
        // for (let i = functions.length - 1; i >= 0; i--) {
        //     result = functions[i](result);
        // }
        // return result;
    };

/**
 * БОЛЬШОЙ FAQ - ОТВЕТЫ НА ВОЗМОЖНЫЕ ВОПРОСЫ:
 * ==========================================
 * 
 * Q: Почему композиция функций выполняется справа налево?
 * A: Это математическая конвенция. В математике (f ∘ g)(x) = f(g(x)), 
 *    что означает сначала применить g, затем f. Это читается справа налево.
 * 
 * Q: Что происходит, если массив функций пустой?
 * A: Возвращается функция-идентичность f(x) = x, которая просто возвращает 
 *    входное значение без изменений.
 * 
 * Q: Можно ли использовать другие методы массива кроме reduceRight?
 * A: Да! Можно использовать:
 *    - reduce() с предварительным реверсом массива
 *    - обычный цикл for с обходом от конца к началу
 *    - рекурсивный подход
 * 
 * Q: Что если одна из функций вернет undefined или null?
 * A: Следующая функция получит undefined/null как входной параметр.
 *    В реальном коде стоит добавить проверки типов.
 * 
 * Q: Как работает reduceRight?
 * A: reduceRight работает как обычный reduce, но обходит массив справа налево.
 *    Синтаксис: array.reduceRight(callback, initialValue)
 *    callback(accumulator, currentValue, currentIndex, array)
 * 
 * Q: Можно ли композировать асинхронные функции?
 * A: Данная реализация работает только с синхронными функциями.
 *    Для асинхронных функций нужен другой подход с async/await или Promise.
 * 
 * Q: Есть ли ограничения на количество функций?
 * A: По условию задачи: 0 <= functions.length <= 1000
 *    В теории JavaScript может обработать и больше, но это зависит от
 *    глубины стека вызовов.
 * 
 * Q: Что если функции имеют побочные эффекты?
 * A: Композиция будет работать, но порядок выполнения побочных эффектов
 *    будет справа налево, что может быть неожиданным.
 * 
 * Q: Можно ли оптимизировать производительность?
 * A: Да, можно:
 *    - Кешировать результаты (мемоизация)
 *    - Предварительно скомпилировать композицию
 *    - Использовать специализированные библиотеки
 * 
 * Q: Как тестировать композицию функций?
 * A: Лучше всего тестировать:
 *    - Каждую функцию отдельно
 *    - Простые композиции из 2-3 функций
 *    - Граничные случаи (пустой массив, одна функция)
 *    - Различные типы входных данных
 * 
 * Q: В чем разница между композицией и пайплайном?
 * A: Композиция идет справа налево: f(g(h(x)))
 *    Пайплайн идет слева направо: h(x) |> g |> f
 *    Результат одинаковый, но порядок написания разный.
 */
};


/**
 * const fn = compose([x => x + 1, x => 2 * x])
 * fn(4) // 9
 */
