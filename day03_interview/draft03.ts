function partitionArray(nums: number[], k: number): number {
  /**
 * Алгоритм решения задачи "Partition Array Such That Maximum Difference Is K":
 * 
 * 1. Суть задачи: нужно разбить массив чисел nums на минимальное количество подпоследовательностей,
 *    так чтобы в каждой подпоследовательности разница между максимальным и минимальным элементом была не больше k.
 * 
 * 2. Ключевая идея: если отсортировать массив, то все элементы, которые могут быть в одной подпоследовательности,
 *    будут идти подряд, так как разница между минимальным и максимальным элементом ограничена k.
 * 
 * 3. Шаги решения:
 *    - Отсортировать массив nums по возрастанию.
 *    - Идти по отсортированному массиву слева направо, запоминая значение первого элемента текущей подпоследовательности.
 *    - Пока разница между текущим элементом и первым элементом подпоследовательности не превышает k, включать элементы в эту подпоследовательность.
 *    - Если разница становится больше k, начать новую подпоследовательность с текущего элемента.
 *    - Подсчитывать количество таких подпоследовательностей.
 * 
 * 4. Сложность:
 *    - Сортировка занимает O(n log n), где n - длина массива.
 *    - Проход по массиву — O(n).
 *    - Общая сложность: O(n log n).
 * 
 * 5. Возвращаемое значение: минимальное количество подпоследовательностей.
 */

    nums.sort((a, b) => a - b);

    let count = 1; // минимум одна подпоследовательность
    let start = nums[0]; // первый элемент текущей подпоследовательности

    for (let i = 1; i < nums.length; i++) {
        if (nums[i] - start > k) {
            count++;        // начинаем новую подпоследовательность
            start = nums[i]; // обновляем стартовый элемент
        }
    }

    return count;

/**
 * Ответы на возможные вопросы:
 * 
 * Q: Почему сортировка нужна?
 * A: Сортировка упорядочивает элементы, что позволяет легко группировать их в подпоследовательности с ограниченной разницей.
 * 
 * Q: Почему мы считаем подпоследовательности по возрастанию?
 * A: Потому что подпоследовательность — это последовательность, сохраняющая порядок элементов из исходного массива,
 *    но удаление элементов не меняет порядок, и сортировка упрощает поиск минимального количества групп.
 * 
 * Q: Можно ли решить задачу без сортировки?
 * A: Теоретически можно, но это будет сложнее и менее эффективно. Сортировка — самый простой и эффективный подход.
 * 
 * Q: Что делать, если k = 0?
 * A: Тогда каждая подпоследовательность может содержать только одинаковые элементы, и количество подпоследовательностей равно количеству уникальных значений.
 * 
 * Q: Какова максимальная длина массива и значения элементов?
 * A: Длина массива до 10^5, значения элементов и k до 10^5. Алгоритм с сортировкой и одним проходом работает эффективно для таких ограничений.
 */
  
};
